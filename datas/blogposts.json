[
    {
        "id": "histoire-fissure",
        "title": "AWS SAA : Pourquoi avoir passé cette certification ?",
        "date": "Jan 15, 2026",
        "category": "DevOps",
        "icon": "aws",
        "readTime": "8 min read",
        "excerpt": "Pourquoi j'ai pris la décision d'apprendre le Cloud et ses enjeux, mon avis et retour d'expérience sur la certification.",
        "content": "<h3 class='text-2xl font-bold text-violet-600 dark:text-violet-400 mb-4'>La découverte du Cloud</h3><p>Tout d'abord, je me suis pris de passion (classique je sais, mais réel) pour le Cloud et le DevOps lorsque j'ai voulu en apprendre plus sur les façons de déployer mon application Fissure.</p><p>Je me suis rendu compte du réel impact que pouvait avoir une infrastructure bien pensée et des enjeux impliqués, que cela soit sur les coûts, la disponibilité (High Availability), la scalabilité et la sécurité.</p><div class='my-8 h-px bg-slate-200 dark:bg-slate-700 w-full'></div><h3 class='text-2xl font-bold text-violet-600 dark:text-violet-400 mb-4'>Une première approche insuffisante</h3><p>Je me suis donc lancé dans l'apprentissage du Cloud en commençant par AWS, le leader du marché. Après avoir appris les bases du réseau, du scripting ainsi que de Linux, j'ai voulu passer la certification <strong>Cloud Practitioner</strong>.</p><p>Cependant, lors de mon apprentissage, je me suis rendu compte qu'elle était trop superficielle. Je voulais apprendre comment architecturer en détail, comprendre les possibilités et les meilleurs choix pour un besoin spécifique.</p><div class='my-8 h-px bg-slate-200 dark:bg-slate-700 w-full'></div><h3 class='text-2xl font-bold text-violet-600 dark:text-violet-400 mb-4'>Le choix de la Solutions Architect Associate</h3><p>Je me suis donc lancé dans l'apprentissage de la certification <strong>AWS Solutions Architect Associate (SAA-C03)</strong>. C'est une certification de niveau intermédiaire qui permet de valider les compétences d'un architecte cloud. Je me suis aussi dit que cela aurait un impact positif sur mon profil et mon CV.</p><p>J'ai donc commencé mon apprentissage et le verdict était clair : bien que théorique, si l'on ne rentre pas dans un bachotage de dumps d'examen, on apprend réellement le Cloud et les services proposés pour déployer l'infrastructure la plus adaptée à un besoin spécifique.</p><p>Bien que dense et nécessitant de se rappeler de beaucoup de détails, l'étude de cette certification m'a permis de comprendre les enjeux et les possibilités du Cloud et de commencer à penser une infra solide pour mon application.</p><div class='my-8 h-px bg-slate-200 dark:bg-slate-700 w-full'></div><h3 class='text-2xl font-bold text-violet-600 dark:text-violet-400 mb-4'>L'examen et le résultat</h3><p>J'ai bien évidemment passé la certification le 2 janvier 2026 et je l'ai obtenue du premier coup ! Le test est assez stressant de par la pression anti-triche de l'examen (j'ai dû reschedule une fois car je portais un casque pour le son...), mais sinon cela s'est très bien passé.</p><p>Je ne peux pas encore dire le réel impact de la certification aux yeux des recruteurs et sur le marché (même si elle est un peu considérée comme le <em>gold standard</em> aux U.S d'un point de vue Cloud). Mais dans tous les cas, l'apprentissage a pour moi été plus intéressant que le badge en lui-même. Je ressors donc satisfait de cette expérience.</p><p class='mt-8 font-medium'>Merci de votre temps et de votre lecture :)</p>"
    },
    {
        "id": "clean-architecture-nextjs",
        "title": "Understanding Clean Architecture in Next.js",
        "date": "Jan 15, 2026",
        "category": "Architecture",
        "readTime": "8 min read",
        "excerpt": "Discover how to implement Clean Architecture principles in your Next.js applications to improve maintainability.",
        "content": "<h3>Why Clean Architecture?</h3><p>Clean Architecture separates your application into layers: Entities, Use Cases, Interface Adapters, and Frameworks. This separation ensures that your business logic is independent of the UI, database, or any external agency.</p><h4>The Layers</h4><ul><li><strong>Entities:</strong> Enterprise business rules.</li><li><strong>Use Cases:</strong> Application business rules.</li><li><strong>Adapters:</strong> Controllers, Gateways, Presenters.</li><li><strong>Infrastructure:</strong> Frameworks, Drivers, Tools.</li></ul><p>In Next.js, this means your API routes (controllers) should call Use Cases, which manipulate Entities, all without knowing whether you're using MongoDB, Postgres, or Vercel KV.</p>"
    },
    {
        "id": "terraform-cert",
        "title": "Terraform Associate : Mon avis sur la certification",
        "date": "Janvier 2026",
        "category": "IaC",
        "readTime": "6 min read",
        "excerpt": "La certification Terraform Associate apprend elle réellement à architecturer en code, ou est-ce juste du bachotage ?",
        "content": "<p>Afin de déployer mon Application sur AWS, j'ai pris une approche IaC pour versionner et coder l'infrastructure, je me suis donc naturellement dit en continuant sur la voie DevOps/SRE que passer la certification pouvait être une bonne méthode d'acquisition une milestone a atteindre. </br> Lors de mon apprentissage, une chose m'est vite venu apres avoir lu toute la documentation et repondu a un premier mock exam : je ne sais toujours pas écrire une seule ligne de terraform et j'obtiens un score de 65% mais devant l'ide [ sans ia ;) ], je comprend le remote state et le locking, mais je suis incapable de designer l'achitecture du code ( modules, outputs... ). Je me suis donc rendu compte que la théorie apprise pour la certification est utile, en effet ce sont des connsaissances auxquels on est rarement confronté mais je sais pas type a finir </p>"
    },
    {
        "id": "optimizing-docker-spring-boot",
        "title": "Optimizing Docker Builds for Spring Boot",
        "date": "Nov 10, 2025",
        "category": "Containerization",
        "readTime": "5 min read",
        "excerpt": "Reduce your Spring Boot Docker image sizes by up to 60% using multi-stage builds and Layered Jar.",
        "content": "<h3>The Problem with Fat Jars</h3><p>Standard Spring Boot fat JARs include all dependencies and application code in a single file. When you change one line of code, Docker has to rebuild the entire layer containing the JAR, wasting bandwidth and storage.</p><h3>Layered Jars</h3><p>Spring Boot 2.3+ supports layered JARs. By separating dependencies, resources, and application code into different layers, you can optimize Docker caching.</p><h4>Dockerfile Example</h4><pre><code>FROM eclipse-temurin:17-jre as builder\nWORKDIR application\nARG JAR_FILE=target/*.jar\nCOPY ${JAR_FILE} application.jar\nRUN java -Djarmode=layertools -jar application.jar extract\n\nFROM eclipse-temurin:17-jre\nWORKDIR application\nCOPY --from=builder application/dependencies/ ./\nCOPY --from=builder application/spring-boot-loader/ ./\nCOPY --from=builder application/snapshot-dependencies/ ./\nCOPY --from=builder application/application/ ./\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]</code></pre>"
    }
]